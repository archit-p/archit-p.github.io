{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/creating-worker-function-goroutines-channels","result":{"pageContext":{"content":"<p>There are times when it's important to split up your long-running jobs into parts or do them parallelly using multithreading. Having worked with DPDK in the past, I had used the rte_ring for inter-process communication. Workers were a prevalent concept in DPDK - being used for packet pipelines and processing.</p>\n<p>When I recently started programming in Go, I discovered how easy Go makes it to write a multi-threaded application. Consider this example.</p>\n<pre><code class=\"language-go\">// FooBar appens \"foobar\" to a string\nfunc FooBar(content string) {\n    content += \"foo\"\n    // do heavy processing\n    content += \"bar\"\n    // do heavy processing\n}\n</code></pre>\n<p>Our function <code>FooBar</code> appends \"foobar\" to the content string while doing arbitrary heavy processing tasks. We'll be focusing on multithreading with this function. To make the function multithreading friendly, let's make it a worker function.</p>\n<pre><code class=\"language-go\">// FooBar appens \"foobar\" to a string\nfunc FooBar(jobs &#x3C;-chan string, results chan&#x3C;- string) {\n    for j := range jobs {\n        j += \"foo\"\n        // do heavy processing\n        j += \"bar\"\n        // do heavy processing\n        results &#x3C;- j\n    }\n}\n</code></pre>\n<p>We've transformed the function by making it take arguments as channels. We keep track of to-do jobs through the jobs channel and push our results into the results channel. Let's now look at how to call our worker function.</p>\n<pre><code class=\"language-go\">func main() {\n    // initialize channels for sending jobs and receiving results\n    job := make(chan string, 5)\n    res := make(chan string, 5)\n    defer close(job)\n    defer close(res)\n\n    // launch the worker in a new goroutine\n    go FooBar(job, res)\n\n    job &#x3C;- \"hello\"\n\n    fmt.Println(&#x3C;-res)\n}\n</code></pre>\n<p>We've just created a basic worker function. Note that we make a call to defer closing the channels to notify our workers to exit cleanly. Now, to make our jobs extensible, let's define them as a new type.</p>\n<pre><code class=\"language-go\">// Job holds meta related to a processing job\ntype Job struct {\n    ID string\n    Content string\n}\n\n// FooBar appens \"foobar\" to a string\nfunc FooBar(jobs &#x3C;-chan Job, results chan&#x3C;- Job) {\n    for j := range jobs {\n        j.Content += \"foo\"\n        // do heavy processing\n        j.Content += \"bar\"\n        // do heavy processing\n        results &#x3C;- j\n    }\n}\n</code></pre>\n<p>We can launch multiple workers as goroutines to speed up processing.</p>\n<pre><code class=\"language-go\">func main() {\n    ...\n\n    numWorkers := 10\n    for i := 0; i &#x3C; numWorkers; i++ {\n        // launch the worker in a new goroutine\n        go FooBar(job, res)\n    }\n    ...\n}\n</code></pre>\n<p>We have an extensible model for multithreading using worker goroutines and channels for passing information. By tweaking <code>numWorkers</code> to the number of cores on our PCs, we can optimally use the CPU and speed up computation.</p>","frontmatter":{"slug":"/blog/creating-worker-function-goroutines-channels","title":"Creating a Worker Function in Go using Goroutines and Channels","date":"August 20th 2020"}}},"staticQueryHashes":[]}